âœ… Phase 3 â€“ Hard SQL 

Topics covered:
âœ” Window Functions (RANK(), DENSE_RANK(), ROW_NUMBER())
âœ” Common Table Expressions (CTE)
âœ” CASE statements
âœ” Nested Subqueries
âœ” Correlated Subqueries
âœ” EXISTS
âœ” LEAD/LAG


ðŸ“˜ Topic 1: RANK(), DENSE_RANK(), ROW_NUMBER()
Window functions are used to assign rankings or order within a partition.

Q1.1: Assign a rank to each employee based on descending salary.
ðŸ‘‰ SELECT name, salary, RANK() OVER (ORDER BY salary DESC) AS rank FROM employees;

Q1.2: Assign row numbers to each order in the orders table sorted by order_date.
ðŸ‘‰ SELECT order_id, order_date, ROW_NUMBER() OVER (ORDER BY order_date) AS row_num FROM orders;


ðŸ“˜ Topic 2: CTE (Common Table Expression)
CTEs are temporary named result sets that simplify complex queries.

Q2.1: Using a CTE, find employees earning above average salary.
ðŸ‘‰ WITH avg_salary_cte AS (SELECT AVG(salary) AS avg_salary FROM employees)
SELECT * FROM employees WHERE salary > (SELECT avg_salary FROM avg_salary_cte);

Q2.2: Using CTE, get top 3 highest-paid employees.
ðŸ‘‰ WITH ranked_emps AS (SELECT name, salary, RANK() OVER (ORDER BY salary DESC) AS rnk FROM employees)
SELECT * FROM ranked_emps WHERE rnk <= 3;


ðŸ“˜ Topic 3: CASE Statement
The CASE statement is like if-else in SQL.
(If No Condition is True then execute Else part)
(If No Condition is True and Else is missing then return NULL)

Q3.1: Label employees as 'High', 'Medium', or 'Low' based on salary (50000 â†’ High, 30000â€“50000 â†’ Medium, <30000 â†’ Low)
ðŸ‘‰ SELECT name, salary,
  CASE
    WHEN salary > 50000 THEN 'High'
    WHEN salary BETWEEN 30000 AND 50000 THEN 'Medium'
    ELSE 'Low'
  END AS salary_level FROM employees;

Q3.2: Show product status as â€˜Availableâ€™ or â€˜Out of Stockâ€™ based on quantity.
ðŸ‘‰ SELECT name, quantity,
  CASE
    WHEN quantity > 0 THEN 'Available'
    ELSE 'Out of Stock'
  END AS status
FROM products;


ðŸ“˜ Topic 4: Correlated Subqueries
A correlated subquery depends on values from the outer query.

Q4.1: Find employees who earn more than the average salary of their department.
ðŸ‘‰ SELECT e.name, e.department, e.salary FROM employees e 
JOIN ( SELECT department, AVG(salary) AS avg_salary FROM employees GROUP BY department ) dept_avg
ON e.department = dept_avg.department WHERE e.salary > dept_avg.avg_salary;
ðŸ‘‰ SELECT e1.name, e1.department, e1.salary FROM employees e1 
WHERE e1.salary > (SELECT AVG(e2.salary) FROM employees e2 WHERE e2.department = e1.department);

Q4.2: Show students who scored the highest marks in their class.
ðŸ‘‰ SELECT s.name, s.class, s.marks FROM students s
JOIN ( SELECT class, MAX(marks) AS max_marks FROM students GROUP BY class ) t
ON s.class = t.class AND s.marks = t.max_marks;
ðŸ‘‰ SELECT s1.name, s1.class, s1.marks FROM students s1 
WHERE s1.marks = (SELECT MAX(s2.marks) FROM students s2 WHERE s2.class = s1.class);


ðŸ“˜ Topic 5: LEAD() and LAG()
LEAD() gets the next rowâ€™s value.
LAG() gets the previous rowâ€™s value.
Useful for comparing rows.

Q11.1: Show each employee's name and the salary of the person who joined after them (based on joining_date).
ðŸ‘‰ SELECT name, salary, LEAD(salary) OVER (ORDER BY joining_date) AS next_joined_salary FROM employees;

Q11.2: List orders and the amount of the previous order for each customer.
ðŸ‘‰ SELECT cust_id, order_id, amount, LAG(amount) OVER (PARTITION BY cust_id ORDER BY order_date) AS prev_order_amount FROM orders;


ðŸ“˜ Topic 6: EXISTS Operator
EXISTS checks if a subquery returns any result. Used for faster filtering than IN.

Q12.1: Find customers who have placed at least one order.
ðŸ‘‰ SELECT * FROM customers c WHERE EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id);

Q12.2: Get students who are enrolled in any course.
ðŸ‘‰ SELECT * FROM students s WHERE EXISTS (SELECT 1 FROM enrollments e WHERE e.student_id = s.student_id);


ðŸ“˜ Topic 7: Subquery in FROM Clause
We can run a subquery in the FROM clause and treat it like a temporary table.

Q13.1: From a list of products, show only those whose price is above the overall average, using a subquery in FROM.
ðŸ‘‰ SELECT * FROM (SELECT name, price, AVG(price) OVER () AS avg_priceFROM products) AS sub WHERE price > avg_price;

Q13.2: Get departments and their employee count, only showing those with count > 3, using subquery in FROM.
ðŸ‘‰ SELECT * FROM (SELECT department, COUNT(*) AS emp_countFROM employeesGROUP BY department) AS dept_stats WHERE emp_count > 3;
