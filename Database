Database

1. Create database s;
a. Show databases;
b. Use database  (Use s;)
c. Rename databases- CREATE DATABASE n;
               RENAME TABLE s.s1 TO n.n1;
d. DROP database if exists s;


2. CREATE TABLE s1 (id INT PRIMARY KEY,
age INT NOT NULL,
name VARCHAR(10) DEFAULT 'modi',
dob DATETIME DEFAULT CURRENT_TIMESTAMP,
yn BOOLEAN DEFAULT 0,
rating FLOAT DEFAULT 9.9);

a. Insert data ( Insert into s1 (id,age,name,dob,yn,rating) values(1,12,‚Äôh‚Äô,‚Äô2004-03-03‚Äô,1,8.9),(),() )

b. Show all table (Show tables;)

c. Rename table  (RENAME TABLE s1 TO s2;)
              //ALTER TABLE s1 RENAME TO s2;Delete table  (Drop table if exists s1;)

d. Delete table  (Drop table if exists s1;)

e. Rename Column  (ALTER TABLE s1 CHANGE COLUMN salary sal int;)

f. Get Table Structure  (desc s1;)  // DESCRIBE s1;

g. Count Row   (SELECT COUNT(*) AS total_rows FROM a5;)


3. Operations on Table data - 
a. Delete one row  (DELETE FROM s1 WHERE id=5;)

b. Update value   (UPDATE s1 SET name = ‚Äòc‚Äô, age=8 WHERE id=0;)

c. Add Column   (ALTER TABLE s1 add COLUMN id int after age;)

d. Drop Column   (ALTER TABLE s1 DROP COLUMN salary;)

e. Remove all data   (TRUNCATE TABLE s1; )  // DELETE FROM a5;

f. Conditional Update   (UPDATE s1 SET yn=TRUE WHERE age > 20;)

g. Copy Table   (CREATE TABLE s1 copy AS select * from s1;)

h. Top N row   (select * from s1 limit 5;)

i. Duplicate row   (select name, COUNT(*) from s1 GROUP BY name HAVING COUNT(*) > 1;)

j. Find NULL values   (SELECT * FROM s1 WHERE name IS NULL;)

k. Row Matching Pattern   SELECT * FROM a5 WHERE name LIKE 'A%'; / ('_A%')

l. Add Unique Constraint   (ALTER TABLE a5 ADD CONSTRAINT unique_name UNIQUE (name);)

üîπ SQL Functions
**Aggregate** (`SUM()`, `AVG()`, `COUNT()`)
**String**     (`LEN()`, `UPPER()`, LOWER())
**Date/Time**  (GETDATE(), DATEPART())
**Conversion** (CAST()`, `CONVERT())



SQL Question

1. find all authors that viewed at least one of their own articles, id in Ascending order
üëâ SELECT distinct author_id AS id FROM Views WHERE author_id = viewer_id Order by id

2. find IDs of invalid tweets. If no. of char in content of tweet is greater than 15.
üëâ Select tweet_id from Tweets where length(content)>15

3. show unique ID of each user, If user not have unique ID replace just show null.
üëâ Select unique_id, name from Employees left Join EmployeeUNI  on Employees.id =  EmployeeUNI.id

4. names of the customer that are either: referred by any customer with id != 2, not referred by any customer.
üëâ Select name from Customer where referee_id is null OR referee_id <> 2

5. Movies with odd-numbered ID and description that is not "boring", Ordered by rating in descending order.
üëâ SELECT id, movie, description, rating FROM Cinema WHERE (id % 2) != 0 AND description != 'boring' ORDER BY rating DESC;

6. Calculate number of unique subjects each teacher, teaches in the university.
üëâ Select teacher_id , Count(Distinct subject_id) as cnt from Teacher Group BY teacher_id

7. name and bonus amount of each employee with a bonus less than 1000.
üëâ SELECT E.name, B.bonus FROM Employee AS E LEFT JOIN Bonus AS B ON E.empID = B.empID WHERE B.bonus < 1000 or B.bonus is Null;

8. Select product id, year, quantity, and price for first year of every product sold.
üëâ SELECT Sales.product_id, FirstYearSales.first_year, Sales.quantity, Sales.price FROM Sales INNER JOIN 
(SELECT product_id, MIN(year) AS first_year FROM Sales GROUP BY product_id) AS FirstYearSales ON Sales.product_id = FirstYearSales.product_id AND Sales.year = FirstYearSales.first_year;

9. Q14.1: Get top 2 highest-paid employees in each department.
üëâ SELECT name, department, salary FROM (SELECT name, department, salary, RANK() OVER (PARTITION BY department ORDER BY salary DESC) 
AS rnk FROM employees) AS ranked WHERE rnk <= 2;

10. Nth Highest Salary.
üëâ Nth Highest Salary :
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
    SET N = N - 1;
    RETURN 
        SELECT salary FROM (
            SELECT DISTINCT salary
            FROM Employee
            ORDER BY salary DESC
            LIMIT 1 OFFSET N
        ) AS temp
    );
END;

11. Name and bonus amount of each employee with a bonus less than 1000.
üëâ SELECT E.name, B.bonus FROM Employee AS E LEFT JOIN Bonus AS B ON E.empID = B.empID WHERE B.bonus < 1000 or B.bonus is Null;

12. Employees who earn more than their managers.
üëâ SELECT e2.name as Employee FROM employee e1 JOIN employee e2 ON e1.id = e2.managerID WHERE e1.salary < e2.salary;

13. Duplicate emails. Note that it's guaranteed that the email field is not NULL.
üëâ Select distinct p1.email as Email from person p1, person p2 where p1.email = p2.email and p1.id != p2.id;

14. All customers who never order anything.
üëâ Select c.name as Customers from Customers c left join Orders o on c.id=o.customerID where o.customerID is Null;

15. delete all duplicate emails
üëâ Delete p1 from person p1 join person p2 on p1.email = p2.email and p1.id > p2.id;

16. all dates id with higher temperatures compared to its previous dates (yesterday).
üëâ SELECT w1.id FROM Weather w1 join Weather w2 on w1.temperature > w2.temperature
Where DATEDIFF(w1.recordDate, w2.recordDate) = 1;

17. 

18. 

19.

20. 

21. product_name, year, and price for each sale_id in the Sales table.
üëâ Select product_name,year,price from Sales left Join Producton on Sales.product_id = Product.product_id
SELECT product_name,year,price FROM Sales JOIN Product USING(product_id);

22. Average experience years of all employees for each project, rounded to 2 digits.
üëâ SELECT p.project_id, ROUND(AVG(e.experience_years), 2) AS average_years FROM Project p JOIN Employee e 
ON p.employee_id = e.employee_id GROUP BY p.project_id;

23. Daily active user count for period of 30 days ending 2019-07-27 inclusively. User was active on someday if they made at least 1 activity on that day.
üëâ SELECT activity_date AS day, COUNT(DISTINCT user_id) AS active_users FROM Activity 
WHERE activity_date BETWEEN DATE_SUB('2019-07-27', INTERVAL 29 DAY) AND '2019-07-27'GROUP BY activity_date;

24. Find each query_name, quality and poor_query_percentage. Both quality and poor_query_percentage to 2 decimal places.
üëâ SELECT query_name,
    ROUND(SUM(rating * 1.0 / position) / COUNT(*), 2) AS quality,
    ROUND(SUM(CASE WHEN rating < 3 THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) AS poor_query_percentage
FROM Queries WHERE query_name IS NOT NULL GROUP BY query_name;

25. Find average selling price for each product (2 decimal) If a product does not have any sold units, its average selling price is assumed to be 0.
üëâ SELECT p.product_id, ROUND(COALESCE(SUM(p.price * u.units) / NULLIF(SUM(u.units), 0), 0), 2) AS average_price
FROM Prices p LEFT JOIN UnitsSold u ON p.product_id = u.product_id AND u.purchase_date 
BETWEEN p.start_date AND p.end_date GROUP BY p.product_id;

26. find percentage of users registered in each contest (2 decimal) Return result table ordered by percentage in desc order. In case of a tie, order it by contest_id in asce order.
üëâ SELECT r.contest_id, ROUND(COUNT(DISTINCT r.user_id) * 100.0 / (SELECT COUNT(*) FROM Users), 2) AS percentage
FROM Register r GROUP BY r.contest_id ORDER BY percentage DESC, r.contest_id ASC;

27. 

28. 

29. 

30. 

31. 

Sub Query :-
Q1. Find employees who earn more than the average salary of the company.
SELECT name, salary FROM employees e WHERE salary > (SELECT AVG(salary) FROM employees);
‚úî Concept: Simple subquery in WHERE.

Q2. Find employees who earn the maximum salary in their department.
SELECT e.name, e.department, e.salary FROM employees e WHERE salary = (SELECT MAX(salary) FROM employees WHERE department=e.department);
‚úî Concept: Correlated subquery (depends on outer query).

Q3. Find departments where at least one employee earns more than 1,00,000.
SELECT DISTINCT department FROM employees e WHERE EXISTS (SELECT 1 FROM employees WHERE department = e.department AND salary > 100000);
‚úî Concept: EXISTS subquery.

Q4. Find students who scored more than the average marks of their class.
SELECT s1.name, s1.class, s1.marks FROM students s1 WHERE s1.marks > (SELECT AVG(s2.marks) FROM students s2 WHERE s2.class = s1.class);
‚úî Concept: Correlated subquery for group-wise comparison.

Q5. Find employees whose salary is among the top 3 salaries in the company.
SELECT DISTINCT salary FROM employees e1 WHERE 3 > (SELECT COUNT(DISTINCT salary) FROM employees e2 WHERE e2.salary > e1.salary);
‚úî Concept: Subquery with COUNT ‚Üí classic ‚ÄúNth highest salary‚Äù problem.

Q6. Show students who scored the highest marks in each class (alternative).
SELECT s.name, s.class, s.marks FROM students s JOIN (SELECT class, MAX(marks) AS max_marks FROM students GROUP BY class) t 
ON s.class = t.class AND s.marks = t.max_marks;
‚úî Concept: Subquery in FROM (derived table).

Q7. Find employees who do not belong to any department listed in the departments table.
SELECT name FROM employees WHERE department NOT IN (SELECT dept_name FROM departments);
‚úî Concept: Subquery in NOT IN.

Q8. Find the second highest salary using a subquery.
SELECT MAX(salary) FROM employees WHERE salary < (SELECT MAX(salary) FROM employees);
‚úî Concept: Nested subquery.
